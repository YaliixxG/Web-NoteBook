## JavaScript 设计模式

### 设计模式概念文字解读

>设计模式是一种被反复使用、思想成熟、经过分类和无数实战经验的总结的。使用设计模式是为了让系统代码可重用、可扩展、可解耦、更容易被人理解且能保证代码可靠性。  
>设计模式使代码开发真正工程化；设计模式是软件工程的基石脉络，如同大厦的机构一样。只有夯实地基搭好结构，才能盖好大楼。也是迈向高级开发人员必经的一步。  

### 设计原则

设计模式存在的根本原因是为了代码复用，增加可维护性。有如下原则：  

    * 开闭原则：对扩展开放，对修改关闭。（高考试卷，为了区分高分学生和低分学生，不能修改原来的题目，但是可以添加一道附加题来进行区分。  
    * 里氏转换原则：子类继承父类，单独掉完全可以运行。（盗版光碟，盗版从正版上翻刻，但是也可以运行）
    * 依赖倒转原则：引用一个对象，如果这个对象有底层类型，直接引用底层。（三个和尚打水，直接可以从井里打水，你非要先把水打到一个桶子里，再打出来，没必要）
    * 接口隔离原则：每一个接口应该是一种角色。（汽车USB插口，对应不同的功能）
    * 合成/聚合复用原则：新的对象应使用一些已有的对象，使之成为新对象的一部分。
    * 迪米特原则：一个对象应对其他对象有尽可能少的了解。  


#### 单例模式  
>单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JS里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。

模式作用：  
    * 模块间通信
    * 系统中某个类的对象只能存在一个
    * 保护自己的属性和方法

注意事项：  
    * 注意this的使用
    * 闭包容易造成内存泄漏，不需要的赶快干掉
    * 注意new的成本  

#### 构造函数模式  
>构造函数用于创建特定类型的对象--不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性和方法。  

>在JS里，构造函数通常是认为用来实现实例的，JS没有类的概念，但是有特殊的构造函数。通过new关键字来调用自定义的构造函数，在构造函数内部，this关键字引用的是新创建的对象。  

模式作用：  
    * 用于创建特定类型的对象
    * 第一次声明的时候给对象赋值
    * 自己声明构造函数，赋予属性和方法

注意事项：  
    * 声明函数的时候处理业务逻辑
    * 区分和单例的区别，配合单例实现初始化
    * 构造函数大写字母开头
    * 注意new的成本（继承）    

#### 建造者模式  
>建造者模式可以将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。建造者模式实际，就是一个指挥者，一个建造者，一个使用指挥者调用具体建造者工作得出的客户。  

>建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。  
>指挥者分配任务，建造者负责开发，各司其职。  

模式作用：  
    * 分布创建一个复杂的对象
    * 解耦封装过程和具体创建的组件
    * 无需关心组件如何组装

注意事项：  
    * 一定要一个稳定的算法进行支持
    * 加工工艺是暴露的  

建造者模式实例：[示例](./test/JS设计模式/builder.html)  

#### 外观模式  
>外观模式为子系统的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。  
>外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。  

模式作用：  
    * 在设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构  （通常意义上的三层架构就是将整个业务应用划分为：界面层、业务逻辑层、数据访问层。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层。）  
    * 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观F可以提供一个简单的接口，减少他们之间的依赖  
    * 在维护一个遗留的大型系统时，为系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互。

注意事项：  
    * 外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性  

外观模式实例：[示例](./test/JS设计模式/facade.js)  

#### 代理模式 Proxy 
>代理，顾名思义就是帮助别人做事。  
>为其他对象提供一种代理以控制对这个对象的访问。代理模式是的代理对象控制具体对象的引用。  
>代理几乎可以是任何对象：文件，资源，内存中的对象，或者是一些难以复制的东西。  

模式作用：  
    * 远程代理（一个对象将不同空间的对象进行局部代理） 
    * 虚拟代理（根据需要创建开销很大的对象如渲染网页暂时用占位代替真图）  
    * 安全代理（控制真实对象的访问权限）
    * 智能指引（调用对象代理处理另外一些事情如垃圾回收机制）

注意事项：  
    * 不能滥用代理，有时候仅仅是给代码增加复杂度  

外观模式实例：[示例](./test/JS设计模式/facade.js)
